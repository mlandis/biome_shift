
print("Configuring regional biome shift process...")

# area x biome -> states
states = [ [  1,  2,  3,  4,  5,  6],
           [  7,  8,  9, 10, 11, 12],
           [ 13, 14, 15, 16, 17, 18] ]

# biome-range clock
rate_biome ~ dnLoguniform( min=1e-4, max=1e1 )
rate_biome.setValue( 3e-2 )

moves[mvi++] = mvScale(rate_biome, lambda=5, weight=5)
moves[mvi++] = mvScale(rate_biome, lambda=1, weight=5)
moves[mvi++] = mvScale(rate_biome, lambda=0.5, weight=3)
moves[mvi++] = mvScale(rate_biome, lambda=0.1, weight=5)

# relative rates of biome/dispersal change
br_base ~ dnUniform(0,1)
br_base.setValue(0.75)
moves[mvi++ ] = mvScale(br_base, lambda=1.0, weight=2)
moves[mvi++ ] = mvScale(br_base, lambda=0.5, weight=2)
dr_base := abs(1.0 - br_base)

# build the biome rate matrix, giving the base rate of shifting from
# biome i into biome j (independent of area/time)

#biome_rates ~ dnDirichlet( rep(1,4) )
for (i in 1:4) {
    biome_rates[i] ~ dnUniform(0,1)
    #biome_rates[i].setValue(1.0)
    moves[mvi++] = mvScale( biome_rates[i], lambda=1.0, weight=2 )
    moves[mvi++] = mvScale( biome_rates[i], lambda=0.5, weight=2 )
}

br_idx = 1
for (i in 1:n_biomes) {
    for (j in 1:n_biomes) {
        br[i][j] := abs(0)
    }
    # ordered character H <-> L <-> T
    if (i < n_biomes) {
        #print( i, i+1, br_idx )
        br[i][i+1] := biome_rates[br_idx++]
    }
    if (i > 1) {
        #print( i, i-1, br_idx )
        br[i][i-1] := biome_rates[br_idx++]
    }
}
br_WT := br[1][2]
br_TW := br[2][1]
br_WC := br[2][3]
br_CW := br[3][2]

# build the base dispersal rates within a given biome (all 1s)
# dispersal rates w/in biome
dr_idx = 1
for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        dr[i][j] <- abs(0)
        if (i != j) {
            dr[i][j] <- abs(1)
        }
    }
}

# weights for using the different graphs
# elements are (LDD-null, SDD-land, biome)
w_graph ~ dnDirichlet( [1,1,1] )
w_graph.setValue( simplex(1,2,16) ) # strong
moves[mvi++] = mvSimplexElementScale(w_graph, alpha=20, weight=5)
moves[mvi++] = mvSimplexElementScale(w_graph, alpha=10, weight=4)
w_U := w_graph[1]
w_G := w_graph[2]
w_B := w_graph[3]
w_not_B := abs(1.0 - w_B)


# areas with subdominant habitats receive the penalty w_subdominant
# areas with only a marginal habitat receive the penalty w_marginal_base * w_subdominant

# rate matrix
# adaptation penalty to biomes that are subdominant/marginal
if (epoch_str == "null") {
    w_adj <- v(1, 1, 1)
} else {
  
    y ~ dnUniform(0,1)
    y.setValue(0.1) # med
    moves[mvi++] = mvScale(y, lambda=2, weight=3)
    moves[mvi++] = mvScale(y, lambda=0.5, weight=3)
    moves[mvi++] = mvScale(y, lambda=0.2, weight=3)
    w_adj := v( 0.0, y, 1.0 )
}



r_epsilon = 1e-4
for (i in 1:n_epochs) {
    print("    building epoch " + i)
    for (j0 in 1:n_biomes) {
        for (j1 in 1:n_biomes) {
            for (k0 in 1:n_areas) {
                s0 = (j0-1) * n_areas + k0
                for (k1 in 1:n_areas) {
                    # simple state
                    s1 = (j1-1) * n_areas + k1

                    # print state
                    #print( i + " -- (" + j0 + ", " + k0 + ") -> (" + j1 + ", " + k1 + ") : " +s0 + " -> " +  s1 )
                  
                    # initialize rate
                    r[i][s0][s1] <- abs(0)
                   
                    # event type
                    diff_biome     = (j0 != j1)
                    diff_area      = (k0 != k1)

                    w0 = j0+1
                    w1 = j1+1

                    if (diff_biome && diff_area) {
                        # one event at a time
                        # ... do nothing
                    } else if (diff_biome) {
                        # what code does area k0 have for biome w1 at time i?
                        w_biome_idx = graph[i][w1][k0][k0] + 1
                        # the transition rate between biomes depends on whether biome j1 is local to area k0/k1
                        r[i][s0][s1] := br_base * br[j0][j1] * (w_not_B + w_B*w_adj[w_biome_idx])
                    } else if (diff_area) {
                        # what code does the edge (k0,k1) have for biome w1 at time i?
                        w_land_idx = graph[i][1][k0][k1] + 1
                        w_biome_idx = graph[i][w1][k0][k1] + 1

                        # the transition rate between areas depends on the current biome state (j0) and the biomes in the destination area (k1)
                        r[i][s0][s1] := dr_base * dr[k0][k1] * (w_U + w_G*w_adj[w_land_idx] + w_B*w_adj[w_biome_idx])
                    }
                }
            }
        }
    }
    Q[i] := fnFreeK(r[i], rescaled=!true, matrixExponentialMethod="scalingAndSquaring")
}



if (epoch_str == "paleo" || epoch_str == "null") {
    Q_epoch := fnEpoch(Q=Q, times=epoch_times, rates=rep(1,n_epochs))
} else if (epoch_str == "modern") {
    Q_epoch := Q[n_epochs]
} else if (epoch_str == "ancient") {
    Q_epoch := Q[1]
}
 

# root frequencies are drawn from a long branch running under the biome-range process, Q
if (epoch_str == "modern") {
    Q_rf := fnFreeK(r[n_epochs], rescaled=!true, matrixExponentialMethod="eigen")
} else {
    Q_rf := fnFreeK(r[1], rescaled=!true, matrixExponentialMethod="eigen")
}

rf_P_limit := Q_rf.getTransitionProbabilities(rate=10.0, startAge=100.0, endAge=root_age)
rf_simplex := simplex(rf_P_limit[2])

print("  clamping m_biome")
m_biome ~ dnPhyloCTMC(tree=phy,
                      Q=Q_epoch,
                      branchRates=rate_biome,
                      rootFrequencies=rf_simplex,
                      type="Standard",
                      nSites=1)

m_biome.clamp(dat_range)
print("  ...clamped!")



