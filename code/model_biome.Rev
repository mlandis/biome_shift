
print("Configuring time-stratified regional biome shift process...")

# Define a matrix where biome-region state values are indexed
# by what biome (row) and what region (column) determines any
# biome-region state's value
states = [ [  1,  2,  3,  4,  5,  6],
           [  7,  8,  9, 10, 11, 12],
           [ 13, 14, 15, 16, 17, 18] ]


# Assign a diffuse prior rate on the biome shift rate that is
# uniform over orders of magnitude

rate_biome ~ dnLoguniform( min=1e-4, max=1e1 )
rate_biome.setValue( 3e-2 )
moves[mvi++] = mvScale(rate_biome, lambda=5, weight=5)
moves[mvi++] = mvScale(rate_biome, lambda=1, weight=5)
moves[mvi++] = mvScale(rate_biome, lambda=0.5, weight=3)
moves[mvi++] = mvScale(rate_biome, lambda=0.1, weight=5)


# Define the expected proportion of biome shift events (br_base)
# relative to dispersal events (dr_base).

br_base ~ dnUniform(0,1)
br_base.setValue(0.5)
moves[mvi++ ] = mvScale(br_base, lambda=1.0, weight=2)
moves[mvi++ ] = mvScale(br_base, lambda=0.5, weight=2)
dr_base := abs(1.0 - br_base)


# Construct the base biome shift rates (\beta_{ij}) between
# all pairs of biomes. We assume all base biome shift rates
# are Uniform(0,1) iid in this analysis, but fix the shift
# rates between Tropical and Cold Temperate biomes to equal
# zero. This is largely to show that one can structure the
# transition rates among biomes under this model.

for (i in 1:n_biomes) {
    for (j in 1:n_biomes) {
        br[i][j] <- abs(0)
    }
}

for (i in 1:4) {
    biome_rates[i] ~ dnUniform(0,1)
    biome_rates[i].setValue(0.5)
    moves[mvi++] = mvScale( biome_rates[i], lambda=1.0, weight=2 )
    moves[mvi++] = mvScale( biome_rates[i], lambda=0.5, weight=2 )
}

br_WT := biome_rates[1]; br[1][2] := br_WT
br_TW := biome_rates[2]; br[2][1] := br_TW
br_WC := biome_rates[3]; br[2][3] := br_WC
br_CW := biome_rates[4]; br[3][2] := br_CW


# Construct the base dispersal rates (\delta_{kl}) for
# between all pairs of regions. We assume all base dispersal
# rates are equal in this analysis (i.e. with the arbitrary
# value of 1). We rely on w_G and Q_G to explain the dispersal
# rate structure among regions.

for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        dr[i][j] <- abs(1)
    }
}

# Construct the vector of mixture weights, w, that will define
#
#    Q(m) = w_U * Q_U + w_G * Q_G + w_B * Q_B
#
# where w_U + w_G + w_B = 1

w_graph ~ dnDirichlet( [1,1,1] )
w_graph.setValue( simplex(1,2,16) ) # strong
moves[mvi++] = mvSimplexElementScale(w_graph, alpha=20, weight=5)
moves[mvi++] = mvSimplexElementScale(w_graph, alpha=10, weight=4)
w_U := w_graph[1]
w_G := w_graph[2]
w_B := w_graph[3]
w_not_B := abs(1.0 - w_B)


# Here we construct we define the parameter values for strong, weak, and
# marginal features for availability/connectivity among biomes/regions.
# In effect, we use the vector w_adj below to translate the strong/weak/marg.
# codes in the various adjacency matrices, A_G(m), A_T(m), A_W(m), A_C(m), into
# the strong (1), weak (0<=y<=1), and marginal (0) values.
y_marginal <- abs(0)
y_strong <- abs(1)
if (epoch_str == "null") {
    w_adj <- v( 1, 1, 1 )
} else {
    y ~ dnUniform(0,1)
    y.setValue(0.1) # med
    moves[mvi++] = mvScale(y, lambda=2, weight=3)
    moves[mvi++] = mvScale(y, lambda=0.5, weight=3)
    moves[mvi++] = mvScale(y, lambda=0.2, weight=3)
    w_adj := v( abs(0.0), y, abs(1.0) )
}



for (i in 1:n_epochs) {
    print("  constructing Q(" + i + ")")
    for (j0 in 1:n_biomes) {
        for (j1 in 1:n_biomes) {
            for (k0 in 1:n_areas) {
                s0 = (j0-1) * n_areas + k0
                for (k1 in 1:n_areas) {
                    # simple state
                    s1 = (j1-1) * n_areas + k1

                  
                    # initialize rate
                    r[i][s0][s1] <- abs(0)
                   
                    # event type
                    diff_biome     = (j0 != j1)
                    diff_area      = (k0 != k1)

                    # biome-graph index (Land:1, Trop:2, Warm:3, Cold:4)
                    w0 = j0 + 1
                    w1 = j1 + 1

                    if (diff_biome && diff_area) {
                        # one event at a time
                        # ... do nothing
                    } else if (diff_biome) {
                        # what feature code does area k0 have for biome w1 at time i?
                        # feature code (Strong:1, Weak:2, Marginal:3)
                        w_B_idx = graph[i][w1][k0][k0] + 1

                        # the transition rate between biomes depends on whether the new biome (j1/w1)
                        # is present in the current region (k0)
                        r[i][s0][s1] := br_base * br[j0][j1] * (w_not_B + w_B*w_adj[w_B_idx])
                    } else if (diff_area) {
                        # what feature code does the edge (k0,k1) have for biome w1 at time i?
                        # feature code (Strong:1, Weak:2, Marginal:3)
                        w_G_idx = graph[i][1][k0][k1] + 1
                        w_B_idx = graph[i][w1][k0][k1] + 1

                        # the transition rate between areas depends on the current biome state (j0)
                        # and the destination area (k1) and the biomes in the destination area (j1/w1)
                        r[i][s0][s1] := dr_base * dr[k0][k1] * (w_U + w_G*w_adj[w_G_idx] + w_B*w_adj[w_B_idx])
                    }
                    
                    if ( !(diff_biome && diff_area) && (s0 != s1) ) {
                        # show rates assigned to each state pair, for non-zero and non-diagonal vallues
                        # uncomment line below to print
                        # print("    " + i + " -- (" + j0 + ", " + k0 + ") -> (" + j1 + ", " + k1 + ") : " +s0 + " -> " +  s1 + " = " + r[i][s0][s1] )
                    }
                }
            }
        }
    }

    # construct the rate matrix, Q(m), from each time interval's rates
    Q[i] := fnFreeK(r[i], rescaled=!true, matrixExponentialMethod="scalingAndSquaring")
}

# Construct the final time-stratified model depending on the assigned biome structure model
if (epoch_str == "paleo" || epoch_str == "null") {
    # all time intervals; note that null assumes w_U <- 1, so structure is ignored
    Q_epoch := fnEpoch(Q=Q, times=epoch_times, rates=rep(1,n_epochs))
} else if (epoch_str == "modern") {
    # final time interval (Recent)
    Q_epoch := Q[n_epochs]
} else if (epoch_str == "ancient") {
    # first time interval (Late Cretaceous)
    Q_epoch := Q[1]
}
 
# Construct the root state probabilities from a long branch running under Q
if (epoch_str == "modern") {
    Q_rf := fnFreeK(r[n_epochs], rescaled=!true, matrixExponentialMethod="eigen")
} else {
    Q_rf := fnFreeK(r[1], rescaled=!true, matrixExponentialMethod="eigen")
}

# We approximately pi_root with exp{mu*Q_rf}_{2} where mu ~= 300. Note, mu is independent
# of the global clock, rate_biome.
rf_P_limit := Q_rf.getTransitionProbabilities(rate=10.0, startAge=100.0, endAge=root_age)
rf_simplex := simplex(rf_P_limit[2])

# Construct the phylogenetic CTMC with the time-stratified regional biome shift process
m_biome ~ dnPhyloCTMC(tree=phy,
                      Q=Q_epoch,
                      branchRates=rate_biome,
                      rootFrequencies=rf_simplex,
                      type="Standard",
                      nSites=1)

m_biome.clamp(dat_range)



