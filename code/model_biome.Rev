
print("Configuring time-stratified regional biome shift process...")

# Define a matrix where biome-region state values are indexed
# by what biome (row) and what region (column) determines any
# biome-region state's value
states = [ [  1,  2,  3,  4,  5,  6],
           [  7,  8,  9, 10, 11, 12],
           [ 13, 14, 15, 16, 17, 18] ]


# Assign a diffuse prior rate on the biome shift rate that is
# uniform over orders of magnitude
rate_biome ~ dnLoguniform( min=1e-4, max=1e1 )
rate_biome.setValue( 3e-2 )
moves[mvi++] = mvScale(rate_biome, lambda=5, weight=5)
moves[mvi++] = mvScale(rate_biome, lambda=1, weight=5)
moves[mvi++] = mvScale(rate_biome, lambda=0.5, weight=3)
moves[mvi++] = mvScale(rate_biome, lambda=0.1, weight=5)

# Define the expected proportion of biome shift events (br_base)
# relative to dispersal events (dr_base).
br_base ~ dnUniform(0,1)
br_base.setValue(0.5)
moves[mvi++ ] = mvScale(br_base, lambda=1.0, weight=2)
moves[mvi++ ] = mvScale(br_base, lambda=0.5, weight=2)
dr_base := abs(1.0 - br_base)

# Construct the base biome shift rates (\beta_{ij}) between
# all pairs of biomes. We assume all base biome shift rates
# are Uniform(0,1) iid in this analysis, but fix the shift
# rates between Tropical and Cold Temperate biomes to equal
# zero. This is largely to show that one can structure the
# transition rates among biomes under this model.

for (i in 1:n_biomes) {
    for (j in 1:n_biomes) {
        br[i][j] <- abs(0)
    }
}

for (i in 1:4) {
    biome_rates[i] ~ dnUniform(0,1)
    #biome_rates[i].setValue(0.5)
    moves[mvi++] = mvScale( biome_rates[i], lambda=1.0, weight=2 )
    moves[mvi++] = mvScale( biome_rates[i], lambda=0.5, weight=2 )
}

br_WT := biome_rates[1]; br[1][2] := br_WT
br_TW := biome_rates[2]; br[2][1] := br_TW
br_WC := biome_rates[3]; br[2][3] := br_WC
br_CW := biome_rates[4]; br[3][2] := br_CW

print(br)

# Construct the base dispersal rates (\delta_{kl}) for
# between all pairs of regions. We assume all base dispersal
# rates are equal in this analysis (i.e. with the arbitrary
# value of 1).
for (i in 1:n_areas) {
    for (j in 1:n_areas) {
        dr[i][j] <- abs(1)
    }
}

# Construct the vector of mixture weights, w, that will define
#
#    Q(m) = w_U * Q_U + w_G * Q_G + w_B * Q_B
#
# where w_U + w_G + w_B = 1

w_graph ~ dnDirichlet( [1,1,1] )
w_graph.setValue( simplex(1,2,16) ) # strong
moves[mvi++] = mvSimplexElementScale(w_graph, alpha=20, weight=5)
moves[mvi++] = mvSimplexElementScale(w_graph, alpha=10, weight=4)
w_U := w_graph[1]
w_G := w_graph[2]
w_B := w_graph[3]
w_not_B := abs(1.0 - w_B)

# Here we construct we define the parameter values for strong,
# weak, and marginal features for availability/connectivity among
# regions and biomes. In effect, we replace the 
# regions/biomes with weak availability/connectivity habitats are multiplied by the penalty factor 0 <= y_weak <= 1
y_marginal <- abs(0)
y_strong <- abs(1)
if (epoch_str == "null") {
    y_subdominant <- 1.0
    y_marginal <- 1.0
} else {
  
    y_subdominant ~ dnUniform(0,1)
    y_subdominant.setValue(0.1) # med
    moves[mvi++] = mvScale(y_subdominant, lambda=2, weight=3)
    moves[mvi++] = mvScale(y_subdominant, lambda=0.5, weight=3)
    moves[mvi++] = mvScale(y_subdominant, lambda=0.2, weight=3)

}

w_adj := v( abs(0.0), y_subdominant, abs(1.0) )


r_epsilon = 1e-4
for (i in 1:n_epochs) {
    print("    building epoch " + i)
    for (j0 in 1:n_biomes) {
        for (j1 in 1:n_biomes) {
            for (k0 in 1:n_areas) {
                s0 = (j0-1) * n_areas + k0
                for (k1 in 1:n_areas) {
                    # simple state
                    s1 = (j1-1) * n_areas + k1

                    # print state (uncomment to view construction of rates, r)
                    #print( i + " -- (" + j0 + ", " + k0 + ") -> (" + j1 + ", " + k1 + ") : " +s0 + " -> " +  s1 )
                  
                    # initialize rate
                    r[i][s0][s1] <- abs(0)
                   
                    # event type
                    diff_biome     = (j0 != j1)
                    diff_area      = (k0 != k1)

                    # biome-graph index (Land:1, Trop:2, Warm:3, Cold:4)
                    w0 = j0 + 1
                    w1 = j1 + 1

                    if (diff_biome && diff_area) {
                        # one event at a time
                        # ... do nothing
                    } else if (diff_biome) {
                        # what feature code does area k0 have for biome w1 at time i?
                        # feature code (Strong:1, Weak:2, Marginal:3)
                        w_B_idx = graph[i][w1][k0][k0] + 1

                        # the transition rate between biomes depends on whether the new biome (j1/w1)
                        # is present in the current region (k0)
                        r[i][s0][s1] := br_base * br[j0][j1] * (w_not_B + w_B*w_adj[w_B_idx])
                    } else if (diff_area) {
                        # what feature code does the edge (k0,k1) have for biome w1 at time i?
                        # feature code (Strong:1, Weak:2, Marginal:3)
                        w_G_idx = graph[i][1][k0][k1] + 1
                        w_B_idx = graph[i][w1][k0][k1] + 1

                        # the transition rate between areas depends on the current biome state (j0)
                        # and the destination area (k1) and the biomes in the destination area (j1/w1)
                        r[i][s0][s1] := dr_base * dr[k0][k1] * (w_U + w_G*w_adj[w_G_idx] + w_B*w_adj[w_B_idx])
                    }
                }
            }
        }
    }
    Q[i] := fnFreeK(r[i], rescaled=!true, matrixExponentialMethod="scalingAndSquaring")
}



if (epoch_str == "paleo" || epoch_str == "null") {
    Q_epoch := fnEpoch(Q=Q, times=epoch_times, rates=rep(1,n_epochs))
} else if (epoch_str == "modern") {
    Q_epoch := Q[n_epochs]
} else if (epoch_str == "ancient") {
    Q_epoch := Q[1]
}
 

# root frequencies are drawn from a long branch running under the biome-range process, Q
if (epoch_str == "modern") {
    Q_rf := fnFreeK(r[n_epochs], rescaled=!true, matrixExponentialMethod="eigen")
} else {
    Q_rf := fnFreeK(r[1], rescaled=!true, matrixExponentialMethod="eigen")
}

rf_P_limit := Q_rf.getTransitionProbabilities(rate=10.0, startAge=100.0, endAge=root_age)
rf_simplex := simplex(rf_P_limit[2])

print("  clamping m_biome")
m_biome ~ dnPhyloCTMC(tree=phy,
                      Q=Q_epoch,
                      branchRates=rate_biome,
                      rootFrequencies=rf_simplex,
                      type="Standard",
                      nSites=1)

m_biome.clamp(dat_range)
print("  ...clamped!")



